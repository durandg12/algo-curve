---
title: "A fast algorithm to compute a curve of confidence upper bounds for the False Discovery Proportion using a reference family with a forest structure"
# subtitle: ""
author:
  - name: Guillermo Durand
    corresponding: true
    email: guillermo.durand@universite-paris-saclay.fr
    url: https://durandg12.github.io/
    orcid: 0000-0003-4056-5631
    affiliations:
      - name: Université Paris-Saclay
        department: Laboratoire de Mathématiques d'Orsay
        url: https://www.imo.universite-paris-saclay.fr/fr/
date: last-modified
date-modified: last-modified
abstract: >+
  This paper presents a new algorithm (and an additional trick) that allows to compute fastly an entire curve of post hoc bounds for the False Discovery Proportion when the underlying bound $V^*_{\mathfrak{R}}$ construction is based on a reference family $\mathfrak{R}$ with a forest structure à la @MR4178188. By an entire curve, we mean the values $V^*_{\mathfrak{R}}(S_1),\dotsc,V^*_{\mathfrak{R}}(S_m)$ computed on a path of increasing selection sets $S_1\subsetneq\dotsb\subsetneq S_m$, $|S_t|=t$. The new algorithm leverages the fact that going from $S_t$ to $S_{t+1}$ is done by adding only one hypothesis.
keywords: [multiple testing, algorithmic, post hoc inference, false discovery proportion, confidence bound]
citation:
  type: article-journal
  container-title: "Computo"
  doi: "xxxx"
  url: https://computo.sfds.asso.fr/algo-curve
  publisher: "Société Française de Statistique"
  issn: "2824-7795"
bibliography: algo-curve.bib
github-user: durandg12
repo: "algo-curve"
draft: true # set to false once the build is running
published: false # will be set to true once accepted
number-sections: true
format:
  computo-html: 
    html-math-method: mathjax
    include-in-header:
      - text: |
          <script>
          window.MathJax = {
            tex: {
              tags: 'ams'
            }
          };
          </script>
  computo-pdf: 
    include-in-header:
      - text: |
          \usepackage{amsmath}
    cite-method: natbib
    natbiboptions: round
---

::: {.hidden}
 \newcommand{\comp}[1]{{#1}^{\mathsf{c}}}
 \newcommand{\Pro}[1]{\mathbb{P}\left(#1\right)} 
 \newcommand{\Esp}[1]{\mathbb{E}\left[ #1 \right]}
 \newcommand{\ind}[1]{\mathbb{1}_{\left\{#1 \right\}}}
 \newcommand{\cH}{\mathcal{H}}
 \newcommand{\cK}{\mathcal{K}}
 \newcommand{\FDP}{\mathrm{FDP}}
 \newcommand{\FDR}{\mathrm{FDR}}
 \newcommand{\JER}{\mathrm{JER}}
 \newcommand{\Rfam}{\mathfrak{R}}
 \newcommand{\Vstar}{V^*_{\Rfam}}
 \newcommand{\Nm}{\mathbb{N}_m}
 \newcommand{\pr}{\mathfrak{pr}}
 \newcommand{\kth}[2]{k^{(#1,#2)}}
:::

# Introduction

# Notation and reference family methodology

## Multiple testing notation {#sec-notation}

## Post hoc bounds with reference families {#sec-reference-fam}

## Deterministic regions with a forest structure

# New algorithms

## Pruning the forest {#sec-pruning}

```pseudocode
#| label: alg-pruning
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Pruning of $\mathfrak{R}$}
\begin{algorithmic}
\Procedure{Pruning}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete}
  \State $\mathcal{K}^{\mathfrak{pr}}\gets\mathcal{K}$
  \State $ H \gets \max_{k\in\mathcal{K}} \phi(k)  $ \Comment{maximum depth}
  \For{$h = H-1, \dotsc, 1$}
    \State $\mathcal{K}^h\gets \{ k\in\mathcal{K} : \phi(k) =h  \}$
    \State $newVec\gets (0)_{k \in  \mathcal{K}^h}$
    \For{$k \in  \mathcal{K}^h$}
      \State $Succ_k \gets \{ k' \in  \mathcal{K}^{h+1} : R_{k'}\subseteq R_k\}$
      \If{$Succ_k=\varnothing$}
        \State $newVec_k \gets \zeta_k$
      \Else
        \If{$\zeta_{k} \geq  \sum_{k'\in Succ_k} Vec_{k'}$}
          \State $\mathcal{K}^{\mathfrak{pr}}\gets \mathcal{K}^{\mathfrak{pr}}\setminus \{ k \}$
        \EndIf
        \State $newVec_k \gets \min\left( \zeta_{k} ,  \sum_{k'\in Succ_k} Vec_{k'}   \right)$
      \EndIf
    \EndFor
    \State $Vec\gets newVec$
  \EndFor
  \State\Return $(\mathcal{K}^{\mathfrak{pr}},\sum_{k\in\mathcal{K}^1} Vec_k  )$
\EndProcedure
\end{algorithmic}
\end{algorithm}
```

::: {#rem-impl-trick}

<!--Remarque dans l'implémentation pratique $Vec$ et $newVec$ sont toujours de taille le nombre de feuilles, et pas le cardinal de $\cK^h$. Et la somme $\sum_{k'\in Succ_k} Vec_{k'}$ est très facilement calculée, si $R_k = \bigcup_{\ell=1}^L P_{i_\ell, i_{\ell+1}}$ alors on somme Vec sur les indices $i_\ell$ à $i_{L+1}$, tout simplement, donc même chercher $Succ_k$ n'est pas nécessaire.-->
:::





## Fast algorithm to compute a curve of confidence bounds on a path of selection sets {#sec-fast-curve}

```pseudocode
#| label: alg-formal-curve
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Formal computation of $(V^*_{\mathfrak{R}}(S_t))_{0\leq t\leq m}$}
\begin{algorithmic}
\Procedure{Curve}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete, path $(S_t)_{1\leq t \leq m}$ with $S_t=\{i_1, \dotsc, i_t\}$}
  \State $\mathcal{P}^0\gets\{(i,i): 1\leq i \leq n\}$ \Comment{the set of all atoms indices}
  \State $\mathcal{K}^-_0\gets\{k\in\mathcal{K} : \zeta_k=0  \}$
  \State $\eta^0_k\gets0$ for all $k\in\mathcal{K}$
  \For{$t=1,\dotsc, m$}
    \If{$i_t\in\bigcup_{k\in\mathcal{K}^-_{t-1}}R_k$}
      \State $\mathcal{P}^t \gets \mathcal{P}^{t-1}$
      \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1}$
      \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$
    \Else
      \For{$h=1,\dotsc,h_{\max}(t)$}
        \State $\eta^t_{k^{(t,h)}}\gets\eta^{t-1}_{k^{(t,h)}} + 1$
        \If{$\eta^t_{k^{(t,h)}}<\zeta_k$}
          \State Pass
        \Else
          \State $h^f_t \gets h$.
          \State $\mathcal{P}^t \gets\left( \mathcal{P}^{t-1}\setminus \{ k\in \mathcal{P}^{t-1} : R_k\subseteq R_{k^{(t,h^f_t)}} \}\right)\cup \{ k^{(t,h^f_t)} \}$
          \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1} \cup \{k^{(t,h^f_t)}\}$
          \State Break the loop
        \EndIf
      \EndFor
      \If{the loop has been broken}
        \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ not visited during the loop, that is all $k\not\in\{k^{(t,h)}, 1\leq h\leq h^f_t   \}$
      \Else
        \State $\mathcal{P}^t \gets \mathcal{P}^{t-1}$
        \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1}$
        \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ not visited during the loop, that is all $k\not\in\{k^{(t,h)}, 1\leq h\leq h_{\max}(t)   \}$
      \EndIf
    \EndIf
  \EndFor
  \State\Return $\mathcal{P}^t, \eta^t_k$ for all $t=1,\dotsc, m$ and $k\in\mathcal{K}$
\EndProcedure
\end{algorithmic}
\end{algorithm}
```

::: {#thm-curve-path}

:::

::: {.proof}

:::

::: {#cor-easy-impl}

:::


```pseudocode
#| label: alg-curve
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Implementation of $(V^*_{\mathfrak{R}}(S_t))_{0\leq t\leq m}$}
\begin{algorithmic}
\Procedure{Curve}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete, path $(S_t)_{1\leq t \leq m}$ with $S_t=\{i_1, \dotsc, i_t\}$}
  \State $V_0\gets 0$
  \State $\mathcal{K}^-\gets\{k\in\mathcal{K} : \zeta_k=0  \}$
  \State $\eta_k\gets 0$ for all $k\in\mathcal{K}$
  \For{$t=1,\dotsc, m$}
    \If{$i_t\in\bigcup_{k\in\mathcal{K}^-}R_k$}
      \State $V_{t}\gets V_{t-1}$
    \Else
      \For{$h=1,\dotsc,h_{\max}(t)$}
        \State find $k^{(t,h)}\in\mathcal{K}^{h}$ such that $i_t\in R_{k^{(t,h)}}$
        \State $\eta_{k^{(t,h)}}\gets\eta_{k^{(t,h)}} + 1$
        \If{$\eta_{k^{(t,h)}}<\zeta_k$}
          \State pass
        \Else
          \State $\mathcal{K}^- \gets \mathcal{K}^-\cup \{ k^{(t,h)} \}$
          \State break the loop
        \EndIf
      \EndFor
     \State $V_{t}\gets V_{t-1} + 1$
    \EndIf
  \EndFor
  \State\Return $(V_t)_{1\leq t \leq m}$
\EndProcedure
\end{algorithmic}
\end{algorithm}
```

# Numerical experiments {#sec-numeric}

# Conclusion

# Acknowledments

This work has been supported by ANR-20-IDEES-0002 (PIA), ANR-19-CHIA-0021 (BISCOTTE), ANR-23-CE40-0018 (BACKUP) and ANR-21-CE23-0035 (ASCAI).

# References {.unnumbered}

::: {#refs}
:::

# Session information {.appendix .unnumbered}

```{r session-info}
sessionInfo()
```

