---
title: "A fast algorithm to compute a curve of confidence upper bounds for the False Discovery Proportion using a reference family with a forest structure"
# subtitle: ""
author:
  - name: Guillermo Durand
    corresponding: true
    email: guillermo.durand@universite-paris-saclay.fr
    url: https://durandg12.github.io/
    orcid: 0000-0003-4056-5631
    affiliations:
      - name: Université Paris-Saclay
        department: Laboratoire de Mathématiques d'Orsay
        url: https://www.imo.universite-paris-saclay.fr/fr/
date: last-modified
date-modified: last-modified
abstract: >+
  This paper presents a new algorithm (and an additional trick) that allows to compute fastly an entire curve of post hoc bounds for the False Discovery Proportion when the underlying bound $V^*_{\mathfrak{R}}$ construction is based on a reference family $\mathfrak{R}$ with a forest structure à la @MR4178188. By an entire curve, we mean the values $V^*_{\mathfrak{R}}(S_1),\dotsc,V^*_{\mathfrak{R}}(S_m)$ computed on a path of increasing selection sets $S_1\subsetneq\dotsb\subsetneq S_m$, $|S_t|=t$. The new algorithm leverages the fact that going from $S_t$ to $S_{t+1}$ is done by adding only one hypothesis.
keywords: [multiple testing, algorithmic, post hoc inference, false discovery proportion, confidence bound]
citation:
  type: article-journal
  container-title: "Computo"
  doi: "xxxx"
  url: https://computo.sfds.asso.fr/algo-curve
  publisher: "Société Française de Statistique"
  issn: "2824-7795"
bibliography: algo-curve.bib
github-user: durandg12
repo: "algo-curve"
draft: true # set to false once the build is running
published: false # will be set to true once accepted
number-sections: true
format:
  computo-html: 
    html-math-method: mathjax
    include-in-header:
      - text: |
          <script>
          window.MathJax = {
            tex: {
              tags: 'ams'
            }
          };
          </script>
  computo-pdf: 
    include-in-header:
      - text: |
          \usepackage{amsmath}
    cite-method: natbib
    natbiboptions: round
    keep-tex: true
---

::: {.hidden}
 \newcommand{\comp}[1]{{#1}^{\mathsf{c}}}
 \newcommand{\Pro}[1]{\mathbb{P}\left(#1\right)} 
 \newcommand{\Esp}[1]{\mathbb{E}\left[ #1 \right]}
 \newcommand{\ind}[1]{\mathbb{1}_{\left\{#1 \right\}}}
 \newcommand{\cH}{\mathcal{H}}
 \newcommand{\cK}{\mathcal{K}}
 \newcommand{\cP}{\mathcal{P}}
 \newcommand{\FDP}{\mathrm{FDP}}
 \newcommand{\FDR}{\mathrm{FDR}}
 \newcommand{\JER}{\mathrm{JER}}
 \newcommand{\Rfam}{\mathfrak{R}}
 \newcommand{\Hoi}{H_{0,i}}
 \newcommand{\Vhat}{\widehat V}
 \newcommand{\Vstar}{V^*_{\Rfam}}
 \newcommand{\Nm}{\mathbb{N}_m}
 \newcommand{\pr}{\mathfrak{pr}}
 \newcommand{\kth}[2]{k^{(#1,#2)}}
:::

# Introduction

Multiple testing theory is often used for exploratory analysis, like Genome-Wide Association Studies, where multiple features are tested to find promising ones. Classical multiple testing theory like Family-Wise Error Rate (FWER) control or False Discovery Rate (FDR) control [@MR1325392] can be used, but a more recent trend consists in the computation of post hoc bounds, also named post selection bounds or confidence envelopes, for the number of false positives, or, equivalently, for the False Discovery Proportion (FDP). This approach is notably advocated for in the context of exploratory research by [@MR2951390, Section 1]. 

Mathematically speaking, a confidence upper bound (we prefer to say upper bound instead of envelope for obvious reasons) is a function $\Vhat : \cP(\Nm^*) \to \Nm$, where $\Nm=\{0,\dotsc,m\}$, $\Nm^*=\{1,\dotsc,m\}$ and $m$ is the number of hypotheses, such that 
$$
\forall \alpha \in ]0,1[, \Pro{\forall S \subseteq \Nm^*, |S\cap \cH_0|\leq \Vhat(S)}\geq 1-\alpha.
$$ {#eq-confidence}
Here, $\alpha$ is a target error rate and $\cH_0$ is the set of hypotheses indices that are true null hypotheses. Note that the construction of $\Vhat$ depends on $\alpha$ and on the random data $X$ and the dependence is omitted to lighten notation and because there is no ambiguity. The meaning of @eq-confidence is that $\Vhat$ provides an upper bound of the number of null hypotheses in $S$ for any selection set $S\subseteq \Nm^*$, which allows the user to perform post hoc selection on their data without breaching the statistical guarantee. Also note that by dividing by $|S|\vee 1$ in @eq-confidence we also get a confidence bound for the FDP:
$$
\forall \alpha \in ]0,1[, \Pro{\forall S \subseteq \Nm^*, \FDP(S)\leq \frac{\Vhat(S)}{|S|\vee 1}}\geq 1-\alpha.
$$ {#eq-confidence-fdp}
So post hoc bounds provide ways to construct FDP-controlling sets instead of FDR-controlling sets, which is much more desirable given the nature of the FDR as an expected value. See for example [@MR3418717, Figure 4] for a credible example where the FDR is controlled but the FDP has a highly undesirable behavior (either 0 because no discoveries at all are made, either higher than the target level).

The first confidence bounds are found in [@MR2279468] and [@MR2279639], although, in the latter, only for selection sets of the form $\{i\in\Nm : P_i\leq t\}$ where $P_i$ is the $p$-value associated to the null hypothesis $\Hoi$. In [@MR2951390] the authors re-wrote the generic construction of [@MR2279468] in terms of closed testing [@MR468056], proposed several practical constructions and sparked a new interest in multiple testing procedures based on confidence envelopes. This work was followed by a prolific series of works like [@MR3305943] and [@MR4731977]. In [@MR4124323], the authors introduce the new point of view of references families (see @sec-reference-fam) to construct post hoc bounds, and show the links between this meta-technique and the closed testing one, along with new bounds. 

Following the reference family trail, in [@MR4178188] the authors introduce new reference families with a special set-theoretic constraint that allows an efficient computation of the bound denoted by $\Vstar$ on a single selection set $S$. The problem is that one often wants to compute $\Vstar$ on a whole path of selection sets $(S_t)_{t\in\Nm^*}$, for example the hypotheses attached to the $t$ smallest $p$-values. Whereas the algorithm provided the aforementioned work [@MR4178188, Algorithm 1] is fast for a single evaluation, it is slow and inefficient to repeatedly call it to compute each $\Vstar(S_t)$. If the $S_t$'s are nested, and growing by one, that is $S_1\subsetneq\dotsb\subsetneq S_m$ and $|S_t|=t$, there is a way to efficiently compute $\left(\Vstar(S_t)\right)_{t\in\Nm}$ by leveraging the nested structure. 

This is the main contribution of the present paper: a new and fast algorithm computing the curve $\left(\Vstar(S_t)\right)_{t\in\Nm}$ for a nested path of selection sets, that is presented in @sec-fast-curve. An additional algorithm that can speed up computations both for the single-evaluation algorithm and the new curve-evaluation algorithm is also presented, in @sec-pruning. In @sec-notation, all necessary notation and vocabulary is re-introduced, most of it being the same as in [@MR4178188]. Finally, a few numerical experiments are presented in Section @sec-numeric to demonstrate the computation time gain.

# Notation and reference family methodology

## Multiple testing notation {#sec-notation}

## Post hoc bounds with reference families {#sec-reference-fam}

## Deterministic regions with a forest structure

# New algorithms

## Pruning the forest {#sec-pruning}

```pseudocode
#| label: alg-pruning
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Pruning of $\mathfrak{R}$}
\begin{algorithmic}
\Procedure{Pruning}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete}
  \State $\mathcal{K}^{\mathfrak{pr}}\gets\mathcal{K}$
  \State $ H \gets \max_{k\in\mathcal{K}} \phi(k)  $ \Comment{maximum depth}
  \For{$h = H-1, \dotsc, 1$}
    \State $\mathcal{K}^h\gets \{ k\in\mathcal{K} : \phi(k) =h  \}$
    \State $newVec\gets (0)_{k \in  \mathcal{K}^h}$
    \For{$k \in  \mathcal{K}^h$}
      \State $Succ_k \gets \{ k' \in  \mathcal{K}^{h+1} : R_{k'}\subseteq R_k\}$
      \If{$Succ_k=\varnothing$}
        \State $newVec_k \gets \zeta_k$
      \Else
        \If{$\zeta_{k} \geq  \sum_{k'\in Succ_k} Vec_{k'}$}
          \State $\mathcal{K}^{\mathfrak{pr}}\gets \mathcal{K}^{\mathfrak{pr}}\setminus \{ k \}$
        \EndIf
        \State $newVec_k \gets \min\left( \zeta_{k} ,  \sum_{k'\in Succ_k} Vec_{k'}   \right)$
      \EndIf
    \EndFor
    \State $Vec\gets newVec$
  \EndFor
  \State\Return $(\mathcal{K}^{\mathfrak{pr}},\sum_{k\in\mathcal{K}^1} Vec_k  )$
\EndProcedure
\end{algorithmic}
\end{algorithm}
```

::: {.callout-tip}

<!--Remarque dans l'implémentation pratique $Vec$ et $newVec$ sont toujours de taille le nombre de feuilles, et pas le cardinal de $\cK^h$. Et la somme $\sum_{k'\in Succ_k} Vec_{k'}$ est très facilement calculée, si $R_k = \bigcup_{\ell=1}^L P_{i_\ell, i_{\ell+1}}$ alors on somme Vec sur les indices $i_\ell$ à $i_{L+1}$, tout simplement, donc même chercher $Succ_k$ n'est pas nécessaire.-->
:::

::: {#prp-pruning}

## Pruning

:::

::: {.proof}

Content
:::


## Fast algorithm to compute a curve of confidence bounds on a path of selection sets {#sec-fast-curve}

```pseudocode
#| label: alg-formal-curve
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Formal computation of $(V^*_{\mathfrak{R}}(S_t))_{0\leq t\leq m}$}
\begin{algorithmic}
\Procedure{Curve}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete, path $(S_t)_{1\leq t \leq m}$ with $S_t=\{i_1, \dotsc, i_t\}$}
  \State $\mathcal{P}^0\gets\{(i,i): 1\leq i \leq n\}$ \Comment{the set of all atoms indices}
  \State $\mathcal{K}^-_0\gets\{k\in\mathcal{K} : \zeta_k=0  \}$
  \State $\eta^0_k\gets0$ for all $k\in\mathcal{K}$
  \For{$t=1,\dotsc, m$}
    \If{$i_t\in\bigcup_{k\in\mathcal{K}^-_{t-1}}R_k$}
      \State $\mathcal{P}^t \gets \mathcal{P}^{t-1}$
      \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1}$
      \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$
    \Else
      \For{$h=1,\dotsc,h_{\max}(t)$}
        \State $\eta^t_{k^{(t,h)}}\gets\eta^{t-1}_{k^{(t,h)}} + 1$
        \If{$\eta^t_{k^{(t,h)}}<\zeta_k$}
          \State Pass
        \Else
          \State $h^f_t \gets h$.
          \State $\mathcal{P}^t \gets\left( \mathcal{P}^{t-1}\setminus \{ k\in \mathcal{P}^{t-1} : R_k\subseteq R_{k^{(t,h^f_t)}} \}\right)\cup \{ k^{(t,h^f_t)} \}$
          \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1} \cup \{k^{(t,h^f_t)}\}$
          \State Break the loop
        \EndIf
      \EndFor
      \If{the loop has been broken}
        \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ not visited during the loop, that is all $k\not\in\{k^{(t,h)}, 1\leq h\leq h^f_t   \}$
      \Else
        \State $\mathcal{P}^t \gets \mathcal{P}^{t-1}$
        \State $\mathcal{K}^-_t \gets \mathcal{K}^-_{t-1}$
        \State $\eta^t_k\gets\eta^{t-1}_k$ for all $k\in\mathcal{K}$ not visited during the loop, that is all $k\not\in\{k^{(t,h)}, 1\leq h\leq h_{\max}(t)   \}$
      \EndIf
    \EndIf
  \EndFor
  \State\Return $\mathcal{P}^t, \eta^t_k$ for all $t=1,\dotsc, m$ and $k\in\mathcal{K}$
\EndProcedure
\end{algorithmic}
\end{algorithm}
```

::: {#thm-curve-path}

## Fast curve computation

:::

::: {.proof}

Content
:::

::: {#cor-easy-impl}

## Easy implementation

:::


```pseudocode
#| label: alg-curve
#| html-indent-size: "1.2em"
#| html-comment-delimiter: "//"
#| html-line-number: true
#| html-line-number-punc: ":"
#| html-no-end: false
#| pdf-placement: "htb!"
#| pdf-line-number: true
\begin{algorithm}
\caption{Implementation of $(V^*_{\mathfrak{R}}(S_t))_{0\leq t\leq m}$}
\begin{algorithmic}
\Procedure{Curve}{$\mathfrak{R}=(R_{k},\zeta_{k})_{k\in\mathcal{K}}$  with $\mathfrak{R}$ complete, path $(S_t)_{1\leq t \leq m}$ with $S_t=\{i_1, \dotsc, i_t\}$}
  \State $V_0\gets 0$
  \State $\mathcal{K}^-\gets\{k\in\mathcal{K} : \zeta_k=0  \}$
  \State $\eta_k\gets 0$ for all $k\in\mathcal{K}$
  \For{$t=1,\dotsc, m$}
    \If{$i_t\in\bigcup_{k\in\mathcal{K}^-}R_k$}
      \State $V_{t}\gets V_{t-1}$
    \Else
      \For{$h=1,\dotsc,h_{\max}(t)$}
        \State find $k^{(t,h)}\in\mathcal{K}^{h}$ such that $i_t\in R_{k^{(t,h)}}$
        \State $\eta_{k^{(t,h)}}\gets\eta_{k^{(t,h)}} + 1$
        \If{$\eta_{k^{(t,h)}}<\zeta_k$}
          \State pass
        \Else
          \State $\mathcal{K}^- \gets \mathcal{K}^-\cup \{ k^{(t,h)} \}$
          \State break the loop
        \EndIf
      \EndFor
     \State $V_{t}\gets V_{t-1} + 1$
    \EndIf
  \EndFor
  \State\Return $(V_t)_{1\leq t \leq m}$
\EndProcedure
\end{algorithmic}
\end{algorithm}
```

# Numerical experiments {#sec-numeric}

# Conclusion

# Acknowledments

This work has been supported by ANR-20-IDEES-0002 (PIA), ANR-19-CHIA-0021 (BISCOTTE), ANR-23-CE40-0018 (BACKUP) and ANR-21-CE23-0035 (ASCAI).

# References {.unnumbered}

::: {#refs}
:::

# Session information {.appendix .unnumbered}

```{r session-info}
sessionInfo()
```

